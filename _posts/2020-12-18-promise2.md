---
title: "JavaScript - Promise 비동기 처리하기 - 2"
excerpt: "Promise.all, Promise.race"
categories:
  - JavaScript
  - frontend
tags:
  - JavaScript
  - frontend
  - 비동기
---

<style>
@font-face { font-family: 'IBMPlexSansKR-Regular';
   src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/noonfonts_20-07@1.0/IBMPlexSansKR-Regular.woff') format('woff'); font-weight: normal; font-style: normal; }
body, a, h3, h4,h1{
font-family: 'IBMPlexSansKR-Regular';
}
td{
	border: 1px solid;
}
</style>

<h3>Promise 비동기 처리 간편하게 하기</h3><br>

<p>
프로젝트를 계속 진행하면서 한 페이지 내에서 많은 api를 불러와야하는 경우들도 생긴다. 메인 페이지를 구성해야하는데 계속 undefined가 뜨길래 왜 그런가 싶었는데 비동기 처리를 해주지 않아서 생긴 일이였다.<br><br>

비동기의 장점은 확실히 한 api를 불러오는 동안 다른 작업을 수행할 수 있으니 수행 시간이 줄어든다는 것이다. 예를 들어 한 페이지 내에서 5개의 api를 불러와야하는데 그걸 다 끝날때까지 기다려야한다면 생각만해도 끔찍하다 ㅋㅋㅋㅋㅋㅋ 나같은 경우에는 작은 프로젝트라 상관없지만 실무에 들어가서 기다려야된다 생각하면 클라이언트 입장에서는 그 웹사이트에 들어가고 싶지않을 것 같다.<br><br>

반면에 단점은 동기식 처리에 비해 설계가 복잡하다. 흔히 말하는 콜백지옥에 빠질 수 있다는 것이다
그렇게 되면 유지보수하기에도 쉽지 않고 가독성도 좋지않다.<br><br>

<b>이러한 단점을 상쇄하기 위해 나온 것이 바로 Promise구문이다!</b><br><br>

Promise 역시 자바스크립트의 객체 중 하나인데, 비동기적으로 실행하는 작업의 결과를 객체화 시킬 수 있다! Promise의 가장 큰 장점이라고 하는데 앞으로 공부하면서 이게 왜 장점인지 더 생각을 해봐야 될 것 같다.<br><br><hr>

</p>

<h3>Promise 객체 생성하기</h3>
Promise는 객체이므로 생성자 함수와 동일하게 객체 구성이 가능하다.

```js
//Promise 객체 만드는 순간 pending상태로 들어간다.
new Promise(
   /* excutor */
   (resolve, reject) => { ... });//pending


const p = new Promise((resolve, reject) => {
     /* pending상태 */
     setTimeout(() => {//일정상태 시간 이후에 실행하게 함
          // fullfiled 상태(이행), 함수 안의 처리가 끝났을 때 호출하는 콜백 함수이다.
          // 어느값이나 인수로 넘길 수 있다.
          console.log('a');
          resolve();
          // 함수안의 처리가 실패햇을 때 실행되는 콜백함수
          // 어느 값이나 인수로 넘길 수 있지만 주로 오류 메세지를 인자로 사용한다.
          reject();
     }, 1000)
});

p.then(() => {
     /* callback */
     console.log('1000ms후에 fullfilled')
     // resolve 된 이후에 실행되는 공간
})
```

[ 결과 ]<br>

- 가장 늦게 종료되는 Promise객체(Promise1)가 끝난후에 values 값이 출력된다.
- return 값이 모두 배열로 처리된다.
- 단, 하나라도 err가 발생하는 경우 모두 에러 처리되며 then 구문은 처리되지않는다.

<a href="https://jsfiddle.net/hjleee/tvh48cxd/23/">JSFiddle에서 실행해보기 </a><br>

<h3>Promise.race </h3>

<p>Promise.race는 단어에서 보여지는대로 가장 먼저 끝나는 Promise가 출력된다. 사실 프로젝트를 진행하면서 가장 먼저 끝나는 Promise가 필요햇던적은 없는것 같다. 강의에서도 실무에서 그렇게 많이 사용되지 않는다고한다. </p>

```js
const promise1 = new Promise((resolve, reject) => {
  setTimeout(resolve, 500, "one");
});

const promise2 = new Promise((resolve, reject) => {
  setTimeout(resolve, 100, "two");
});

Promise.race([promise1, promise2]).then((value) => {
  console.log(value);
  // Both resolve, but promise2 is faster
});
```

[ 결과 ]

- 가장 빨리 끝나는 two가 출력된다.
- 가장 빨리 끝나는 함수가 err가 나는 경우에만 에러처리가 된다.
  <br><br>

<a href="https://jsfiddle.net/hjleee/tvh48cxd/26/">JSFiddle에서 실행해보기 </a><br>
사실 Promise.all같은 경우에는 지금 내 프로젝트에도 바로 적용시킬 수 있을 것 같은데 Promise.race같은 경우는 아직 사실 어느 상황에서 써야하는 지 감이 안온다. 더 많은 예제를 접하거나 race를 사용하는 경우가 명확한 경우라면 확실히 이해할 수 있을 것 같다.

<hr>

<b>참고 문서</b>

- <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/all">MDN</a>
- 모던 자바스크립트 입문(길벗 출판사)
- <a href="https://www.fastcampus.co.kr/"> 패스트 캠퍼스 </a>프론트엔드 강의
